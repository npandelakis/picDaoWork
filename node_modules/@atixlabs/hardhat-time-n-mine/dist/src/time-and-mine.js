"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("./helpers");
const param_parsing_1 = require("./param-parsing");
const mineOneBlock = async (hre) => hre.network.provider.send("evm_mine", []);
const mineChunk = async (hre, amount) => Promise.all(Array.from({ length: amount }, () => mineOneBlock(hre)));
const mine = (hre) => async (amount) => {
    if (amount < 0)
        throw new Error("mine cannot be called with a negative value");
    const MAX_PARALLEL_CALLS = 1000;
    // Do it on parallel but do not overflow connections
    for (let i = 0; i < Math.floor(amount / MAX_PARALLEL_CALLS); i++) {
        await mineChunk(hre, MAX_PARALLEL_CALLS);
    }
    return mineChunk(hre, amount % MAX_PARALLEL_CALLS);
};
const increaseTime = (hre) => async (delta) => {
    const deltaInSeconds = param_parsing_1.parseDelta(delta);
    return hre.network.provider.send("evm_increaseTime", [deltaInSeconds]);
};
const setTimeIncrease = (hre) => async (delta) => {
    const deltaInSeconds = param_parsing_1.parseDelta(delta);
    const latestBlock = await helpers_1.getLastBlock(hre);
    const nextTimestamp = parseInt(latestBlock.timestamp, 16) + deltaInSeconds;
    await setTimeNextBlock(hre)(nextTimestamp);
};
const setTime = (hre) => (time) => hre.network.provider.send("evm_mine", [time]);
const setTimeNextBlock = (hre) => (time) => hre.network.provider.send("evm_setNextBlockTimestamp", [
    time,
]);
exports.default = (hre) => ({
    increaseTime: increaseTime(hre),
    setTimeIncrease: setTimeIncrease(hre),
    mine: mine(hre),
    setTime: setTime(hre),
    setTimeNextBlock: setTimeNextBlock(hre),
});
//# sourceMappingURL=time-and-mine.js.map